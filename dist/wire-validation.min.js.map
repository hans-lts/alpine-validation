{"version":3,"file":"wire-validation.min.js","sources":["../src/index.js","../builds/cdn.js"],"sourcesContent":["export function bindComponent(el, Alpine) {\n    Alpine.bind(el, {\n        'x-data'() {\n            return {\n                errors: [],\n                models: [],\n                errorsFor(model) {                    \n                    // Checking for any errors\n                    if(!model) {\n                        let errors = [];\n\n                        for(let result of this.models) {\n                            errors.push(...this.errors[result])\n                        }                        \n                        return errors;\n                    }\n\n                    if(model.includes('*')) {\n                        let models = this.wildcardModelSearch(model);\n                        let errors = [];\n\n                        for(let result of models) {\n                            errors.push(...this.errors[result])\n                        }\n                        return errors;\n                    }\n                    return this.errors[model] ?? [];\n                },\n                firstErrorFor(model) {                    \n                    return this.errorsFor(model)[0]\n                },\n                hasErrors(model) {\n                    return this.errorsFor(model).length > 0 ?? false;\n                },\n                processValidation(errors) {\n                    this.errors = errors;\n                    this.models = Object.keys(errors);\n                },\n                wildcardModelSearch(term) {\n                    let rx = new RegExp(term.replaceAll('*', '.*'))\n                    return this.models.filter(model => rx.test(model));\n                }\n            }\n        }\n    })\n}\n\nexport function bindLivewireV2Hook() {\n    Livewire.hook('message.processed', (message, component) => {\n        let alpineComponent = Alpine.$data(component.el);\n\n        // Make sure we aren't going to call an invalid alpine component\n        if (alpineComponent.processValidation) {\n            alpineComponent.processValidation(message.response.serverMemo.errors);\n        }\n    });\n}\n\nexport function bindLivewireV3Hook() {\n    Livewire.hook('commit', ({component, commit, respond, succeed, fail}) => {\n        succeed(({snapshot, effect}) => {\n            let alpineComponent = Alpine.$data(component.el);\n\n            if (alpineComponent.processValidation) {\n                alpineComponent.processValidation(JSON.parse(snapshot).memo.errors);\n            }\n        })\n    });\n}\n\nexport default function (Alpine) {\n    (Livewire.components?.hooks !== undefined) ? \n        bindLivewireV2Hook() : \n        bindLivewireV3Hook();\n\n    Alpine.directive('wire-errors', (el, { modifiers }, { Alpine }) => {\n        bindComponent(el, Alpine);\n    }).before('bind')\n\n    \n    // Gives the ability to check on another component's errors\n    // which might be useful if one component's activity \n    // depends on the error state of another\n    Alpine.magic('componentErrors', (el, { Alpine }) => (elementId, model) => {\n        let element = document.getElementById(elementId);\n\n        if(!element) {\n            console.warn(`Element ${elementId} not found`)\n            return [];\n        }\n\n        let stack = Alpine.$data(element);\n\n        if(!stack || !stack.$root.id === elementId) {\n            console.warn(`Element ${elementId} is not an AlpineJs component`)\n            return [];\n        }\n\n        return stack.errorsFor(model);\n    })\n}","import ComponentErrors from '../src/index.js';\n\ndocument.addEventListener('alpine:init', () => {\n    window.Alpine.plugin(ComponentErrors)\n})"],"names":["bindLivewireV2Hook","Livewire","hook","message","component","alpineComponent","Alpine","$data","el","processValidation","response","serverMemo","errors","bindLivewireV3Hook","commit","respond","succeed","fail","snapshot","effect","JSON","parse","memo","ComponentErrors","undefined","components","hooks","directive","modifiers","bind","x-data","models","errorsFor","model","result","this","push","includes","wildcardModelSearch","firstErrorFor","hasErrors","length","Object","keys","term","rx","RegExp","replaceAll","filter","test","bindComponent","before","magic","elementId","element","document","getElementById","console","warn","stack","$root","id","addEventListener","window","plugin"],"mappings":"2FA+CO,SAASA,IACZC,SAASC,KAAK,qBAAqB,CAACC,EAASC,KACzC,IAAIC,EAAkBC,OAAOC,MAAMH,EAAUI,IAGzCH,EAAgBI,mBAChBJ,EAAgBI,kBAAkBN,EAAQO,SAASC,WAAWC,OAClE,GAER,CAEO,SAASC,IACZZ,SAASC,KAAK,UAAU,EAAEE,YAAWU,SAAQC,UAASC,UAASC,WAC3DD,GAAQ,EAAEE,WAAUC,aAChB,IAAId,EAAkBC,OAAOC,MAAMH,EAAUI,IAEzCH,EAAgBI,mBAChBJ,EAAgBI,kBAAkBW,KAAKC,MAAMH,GAAUI,KAAKV,OAChE,GACF,GAEV,CAEe,SAAAW,EAAUjB,QACWkB,IAA/BvB,SAASwB,YAAYC,MAClB1B,IACAa,IAEJP,EAAOqB,UAAU,eAAe,CAACnB,GAAMoB,cAAetB,cA3EnD,SAAuBE,EAAIF,GAC9BA,EAAOuB,KAAKrB,EAAI,CACZ,SAAQsB,KACG,CACHlB,OAAQ,GACRmB,OAAQ,GACRC,SAAAA,CAAUC,GAEN,IAAIA,EAAO,CACP,IAAIrB,EAAS,GAEb,IAAI,IAAIsB,KAAUC,KAAKJ,OACnBnB,EAAOwB,QAAQD,KAAKvB,OAAOsB,IAE/B,OAAOtB,CACX,CAEA,GAAGqB,EAAMI,SAAS,KAAM,CACpB,IAAIN,EAASI,KAAKG,oBAAoBL,GAClCrB,EAAS,GAEb,IAAI,IAAIsB,KAAUH,EACdnB,EAAOwB,QAAQD,KAAKvB,OAAOsB,IAE/B,OAAOtB,CACX,CACA,OAAOuB,KAAKvB,OAAOqB,IAAU,EAChC,EACDM,aAAAA,CAAcN,GACV,OAAOE,KAAKH,UAAUC,GAAO,EAChC,EACDO,SAAAA,CAAUP,GACN,OAAOE,KAAKH,UAAUC,GAAOQ,OAAS,IAAK,CAC9C,EACDhC,iBAAAA,CAAkBG,GACduB,KAAKvB,OAASA,EACduB,KAAKJ,OAASW,OAAOC,KAAK/B,EAC7B,EACD0B,mBAAAA,CAAoBM,GAChB,IAAIC,EAAK,IAAIC,OAAOF,EAAKG,WAAW,IAAK,OACzC,OAAOZ,KAAKJ,OAAOiB,QAAOf,GAASY,EAAGI,KAAKhB,IAC/C,KAIhB,CA+BQiB,CAAc1C,EAAIF,EAAO,IAC1B6C,OAAO,QAMV7C,EAAO8C,MAAM,mBAAmB,CAAC5C,GAAMF,YAAa,CAAC+C,EAAWpB,KAC5D,IAAIqB,EAAUC,SAASC,eAAeH,GAEtC,IAAIC,EAEA,OADAG,QAAQC,KAAM,WAAUL,eACjB,GAGX,IAAIM,EAAQrD,EAAOC,MAAM+C,GAEzB,OAAIK,IAAUA,EAAMC,MAAMC,KAAOR,EAK1BM,EAAM3B,UAAUC,IAJnBwB,QAAQC,KAAM,WAAUL,kCACjB,GAGkB,GAErC,CClGAE,SAASO,iBAAiB,eAAe,KACrCC,OAAOzD,OAAO0D,OAAOzC,EAAgB"}